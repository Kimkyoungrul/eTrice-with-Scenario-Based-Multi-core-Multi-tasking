/**
 * @author generated by eTrice
 *
 * Source File of ProtocolClass PTimer
 * 
 */

#include "PTimer.h"
#include "debugging/etMSCLogger.h"
#include "PTimer_Utils.h"


/*--------------------- port methods */

void PTimerPort_timeout(const PTimerPort* self) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerPort", "timeout")
		etPort_sendMessage(self, PTimer_OUT_timeout, 0, NULL);
		ET_MSC_LOGGER_ASYNC_OUT(self->myInstName, "timeout", self->peerInstName)
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerReplPort_timeout_broadcast(const PTimerReplPort* self) {
	int i;
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerReplPort", "timeout")
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		etPort_sendMessage((&((etReplPort*)self)->ports[i].port), PTimer_OUT_timeout, 0, NULL);
		ET_MSC_LOGGER_ASYNC_OUT(((etReplPort*)self)->ports[i].port.myInstName, "timeout", ((etReplPort*)self)->ports[i].port.peerInstName)
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

void PTimerReplPort_timeout(const PTimerReplPort* self, int idx__et) {
	ET_MSC_LOGGER_SYNC_ENTRY("PTimerReplPort", "timeout")
	if (0<=idx__et && idx__et<((etReplPort*)self)->size) {
		etPort_sendMessage((&((etReplPort*)self)->ports[idx__et].port), PTimer_OUT_timeout, 0, NULL);
		ET_MSC_LOGGER_ASYNC_OUT(((etReplPort*)self)->ports[idx__et].port.myInstName, "timeout", ((etReplPort*)self)->ports[idx__et].port.peerInstName)
	}
	ET_MSC_LOGGER_SYNC_EXIT
}

etInt32 PTimerReplPort_getReplication(const PTimerReplPort* self) {
	return ((etReplPort*)self)->size;
}



void PTimerConjPort_startTimer(const PTimerConjPort* self, uint32 data__et) {
	if (status==0){
		status=ET_TIMER_RUNNING | ET_TIMER_PERIODIC;

		etPort_sendMessage(self, PTimer_IN_startTimer, sizeof(int32), &data__et);
	}
}

void PTimerConjReplPort_startTimer_broadcast(const PTimerConjReplPort* self, uint32 data__et) {
	int i;
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		PTimerConjPort_startTimer(&((etReplPort*)self)->ports[i].port, data__et);
	}					
}

void PTimerConjReplPort_startTimer(const PTimerConjReplPort* self, int idx__et, uint32 data__et) {
	PTimerConjPort_startTimer(&((etReplPort*)self)->ports[idx__et].port, data__et);
}


void PTimerConjPort_startTimeout(const PTimerConjPort* self, uint32 data__et) {
	if (status==0){
		status = ET_TIMER_RUNNING;
		etPort_sendMessage(self, PTimer_IN_startTimeout, sizeof(int32), &data__et);
	}
}

void PTimerConjReplPort_startTimeout_broadcast(const PTimerConjReplPort* self, uint32 data__et) {
	int i;
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		PTimerConjPort_startTimeout(&((etReplPort*)self)->ports[i].port, data__et);
	}					
}

void PTimerConjReplPort_startTimeout(const PTimerConjReplPort* self, int idx__et, uint32 data__et) {
	PTimerConjPort_startTimeout(&((etReplPort*)self)->ports[idx__et].port, data__et);
}


void PTimerConjPort_kill(const PTimerConjPort* self) {
	if (status!=0){
		status=0;
		etPort_sendMessage(self, PTimer_IN_kill, 0,NULL);
	}
}

void PTimerConjReplPort_kill_broadcast(const PTimerConjReplPort* self) {
	int i;
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		PTimerConjPort_kill(&((etReplPort*)self)->ports[i].port);
	}					
}

void PTimerConjReplPort_kill(const PTimerConjReplPort* self, int idx__et) {
	PTimerConjPort_kill(&((etReplPort*)self)->ports[idx__et].port);
}

/* begin PTimerConjPort specific (including base classes) */

/*--------------------- operations ---------------------*/
/* end PTimerConjPort specific (including base classes) */

etInt32 PTimerConjReplPort_getReplication(const PTimerConjReplPort* self) {
	return ((etReplPort*)self)->size;
}

/* receiver handlers */
void PTimerConjPort_timeout_receiveHandler(PTimerConjPort* self, const etMessage* msg, void * actor, etActorReceiveMessage receiveMessageFunc){
	/* TODO: clear active bit in case of single shot timer */
	if (status!=0){
		if (status==ET_TIMER_RUNNING){
			/* single shot timer */
			status=0;
			}
		/* msg to fsm */
		(*receiveMessageFunc)(actor, self, msg);
	}
	/* hand over the message to the actor:      */
	/* (*receiveMessageFunc)(actor, self, msg); */
}


/*--------------------- debug helpers */

/* message names as strings for debugging (generate MSC) */
static const char* const PTimer_messageStrings[] = {"MIN", "timeout","startTimer", "startTimeout", "kill", "MAX"};

const char* PTimer_getMessageString(int msg_id) {
	if (msg_id<PTimer_MSG_MIN || msg_id>PTimer_MSG_MAX+1){
		/* id out of range */
		return "Message ID out of range";
	}
	else{
		return PTimer_messageStrings[msg_id];
	}
}
