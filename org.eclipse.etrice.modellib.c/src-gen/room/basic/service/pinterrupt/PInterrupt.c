/**
 * @author generated by eTrice
 *
 * Source File of ProtocolClass PInterrupt
 * 
 */

#include "PInterrupt.h"
#include "debugging/etMSCLogger.h"
#include "PInterrupt_Utils.h"


/*--------------------- port methods */
etInt32 PInterruptReplPort_getReplication(const PInterruptReplPort* self) {
	return ((etReplPort*)self)->size;
}



void PInterruptConjPort_event(const PInterruptConjPort* self) {
	// the message should be sent via the fire operation !!
}

void PInterruptConjReplPort_event_broadcast(const PInterruptConjReplPort* self) {
	int i;
	for (i=0; i<((etReplPort*)self)->size; ++i) {
		PInterruptConjPort_event(&((etReplPort*)self)->ports[i].port);
	}					
}

void PInterruptConjReplPort_event(const PInterruptConjReplPort* self, int idx__et) {
	PInterruptConjPort_event(&((etReplPort*)self)->ports[idx__et].port);
}

/* begin PInterruptConjPort specific (including base classes) */
/*--------------------- begin user code ---------------------*/
#include "messaging/etMessageService.h"
/*--------------------- end user code ---------------------*/

/*--------------------- operations ---------------------*/
 PInterruptConjPort* PInterruptConjPort_export(PInterruptConjPort* self) {
	msg.address = self->peerAddress;
	msg.evtID = PInterrupt_IN_event;
	callback.func=(void (*)(void*))PInterruptConjPort_dispatch;
	callback.param=(void *)self;
	etMessageService_registerHighPrioFunc(self->msgService,&callback);
	return self;
}
 void PInterruptConjPort_dispatch(PInterruptConjPort* self) {
	// this operation will be executed from the message service
	if (enable){
		enable=0;
		self->msgService->msgDispatcher(&msg);
	}
}
 void PInterruptConjPort_fire(PInterruptConjPort* self) {
	// this method runs on interrupt level
	enable=1;
	etSema_wakeupFromISR(&self->msgService->executionSemaphore);
}
/* end PInterruptConjPort specific (including base classes) */

etInt32 PInterruptConjReplPort_getReplication(const PInterruptConjReplPort* self) {
	return ((etReplPort*)self)->size;
}



/*--------------------- debug helpers */

/* message names as strings for debugging (generate MSC) */
static const char* const PInterrupt_messageStrings[] = {"MIN", "event", "MAX"};

const char* PInterrupt_getMessageString(int msg_id) {
	if (msg_id<PInterrupt_MSG_MIN || msg_id>PInterrupt_MSG_MAX+1){
		/* id out of range */
		return "Message ID out of range";
	}
	else{
		return PInterrupt_messageStrings[msg_id];
	}
}
